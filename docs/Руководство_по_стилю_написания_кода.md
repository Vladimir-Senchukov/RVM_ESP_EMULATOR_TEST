
## Содержание

1. [Структура файлов и модульность]
2. [Именование]
3. [Типы данных и константы]
4. [Обработка ошибок]
5. [Документация и комментарии]
6. [Логирование]
7. [Форматирование кода]
8. [Безопасность и защитные меры]
9. [Работа с оборудованием]
10. [Примеры правильного кода]

---

## 1. Структура файлов и модульность

### Заголовки файлов

- Каждый файл должен начинаться с блока Doxygen-комментариев, описывающего назначение файла
- Использовать include guards для всех заголовочных файлов, не использовать `#pragma once`

```c
/**
 * @file module_name.h
 * @brief Краткое описание модуля
 *
 * Более подробное описание, если необходимо
 */
#ifndef MODULE_NAME_H
#define MODULE_NAME_H

// Содержимое файла

#endif /* MODULE_NAME_H */
```

### Организация кода

- Логическое расположение в .c файлах:
    1. Включения заголовочных файлов
    2. Определения констант и макросов
    3. Объявления статических переменных
    4. Объявления и реализации статических функций
    5. Реализации публичных функций

### Инкапсуляция

- Функции, используемые только внутри .c файла, должны быть объявлены как `static`
- **Документация для статических функций располагается в .c файле**
- **Документация для публичных функций располагается в заголовочном (.h) файле**

---

## 2. Именование

### Общие правила

- Использовать содержательные имена, отражающие назначение
- Предпочтительно использовать `snake_case` для функций и переменных
- Использовать `UPPER_SNAKE_CASE` для констант и макросов

### Префиксы и суффиксы

- Префикс модуля для всех функций модуля: `module_name_function_name`
- Префикс `g_` для глобальных и глобальных статических переменных: `g_variable_name`
- Суффикс `_t` для пользовательских типов данных: `module_name_type_t`

### Примеры

```c
// Функция модуля
ds28e18_core_status_t ds28e18_init(void);

// Глобальная переменная
static uint8_t g_sequencer_data[512];

// Пользовательский тип
typedef enum {
    DS28E18_CORE_STATUS_OK = 0U,
    DS28E18_CORE_STATUS_ERROR = 1U,
    // ...
} ds28e18_core_status_t;
```

---

## 3. Типы данных и константы

### Точные типы

- Всегда использовать точные типы данных из `<stdint.h>`: `uint8_t`, `int16_t`, `uint32_t` и т.д.
- Не использовать общие типы как `int`, `char`, `long`

### Константность

- **Если параметр функции не изменяется в функции, добавить квалификатор `const`**
- Для указателей на неизменяемые данные: `const uint8_t * const data`
    - Первый `const` означает, что данные неизменяемы
    - Второй `const` означает, что сам указатель неизменяем

### Булевы значения

- Использовать `bool` из `<stdbool.h>` для логических значений
- Предпочитать `true`/`false` вместо `1`/`0` для логических значений

### Константы и перечисления

- Избегать "магических чисел" в коде, всегда определять именованные константы
- Группировать связанные константы в перечисления

```c
// Правильно
#define MAX_BUFFER_SIZE 512

// Или лучше
enum {
    MAX_BUFFER_SIZE = 512
};
```

---

## 4. Обработка ошибок

### Коды возврата

- **Функции должны возвращать коды состояния:**
    - **0 всегда означает успех**
    - **Ненулевые значения означают ошибки**

### Типизированные статусы

- Использовать типизированные перечисления для кодов состояния:

```c
typedef enum {
    MODULE_STATUS_OK = 0U,                  // Успешное выполнение
    MODULE_STATUS_ERROR = 1U,               // Общая ошибка
    MODULE_STATUS_INVALID_PARAMETER = 2U,   // Недопустимый параметр
    // ...
} module_status_t;
```

### Проверка и обработка

- Проверять коды возврата немедленно после вызова функций
- Каскадно передавать ошибки вверх по стеку вызовов
- Логировать ошибки с достаточной информацией для диагностики

```c
module_status_t function(void) {
    if (another_function() != MODULE_STATUS_OK) {
        LOGE(__func__, "Another function failed");
        return MODULE_STATUS_ERROR;
    }
    return MODULE_STATUS_OK;
}
```

---

## 5. Документация и комментарии

### Документация функций

- Все публичные функции должны иметь Doxygen-документацию
- Включать следующую информацию:
    - `@brief` - краткое описание
    - `@param` - описание каждого параметра
    - `@return` - описание возвращаемого значения
    - `@note`, `@warning` - при необходимости

```c
/**
 * @brief Инициализирует устройство DS28E18
 *
 * Выполняет сброс устройства, проверяет наличие на шине
 * и настраивает базовые параметры.
 *
 * @return ds28e18_core_status_t DS28E18_CORE_STATUS_OK при успехе, 
 *                              код ошибки при неудаче
 */
ds28e18_core_status_t ds28e18_init(void);
```

### Комментарии в коде

- Комментировать сложные блоки кода и неочевидные решения
- Избегать избыточных комментариев для очевидных операций
- Использовать однотипное форматирование комментариев

---

## 6. Логирование

### Уровни логирования

- `LOGI` - информационные сообщения
- `LOGD` - детальные сообщения для отладки
- `LOGW` - предупреждения
- `LOGE` - сообщения об ошибках

### Формат

- **Если имя функции ≤ 20 символов: `LOGx(__func__, ...)`**
- **Если имя функции > 20 символов: `LOGx("func_cut_name", ...)`**
- Первый аргумент - контекст (обычно имя модуля или функции)
- Сообщения должны быть информативными и лаконичными

```c
LOGI(__func__, "DS28E18 init completed successfully");
LOGE("module_name", "Failed to initialize device, error: %d", error_code);
```

### Условное логирование

- Отладочные логи можно включать/выключать через определение DEBUG

```c
#ifdef DEBUG_MODULE
LOGD(__func__, "Debug value: %d", value);
#endif
```

---

## 7. Форматирование кода

### Отступы и скобки

- Использовать 4 пробела для отступов, не табуляции
- Открывающая фигурная скобка на той же строке, что и выражение/условие
- Закрывающая фигурная скобка на отдельной строке

```c
if (condition) {
    // Код
} else {
    // Код
}
```

### Пробелы

- Пробелы вокруг бинарных операторов: `a + b`
- Пробелы после запятых: `function(a, b, c)`
- Пробелы после ключевых слов: `if (condition)`
- Без пробелов между именем функции и скобками: `function()`

### Максимальная длина строки

- Примерно 100 символов
- Длинные строки разбивать логически

---

## 8. Безопасность и защитные меры

### Проверка параметров

- Проверять все входные параметры в начале функции
- Возвращать код ошибки при недопустимых параметрах

```c
if (param == NULL || size > MAX_SIZE) {
    LOGE(__func__, "Invalid parameters");
    return MODULE_STATUS_INVALID_PARAMETER;
}
```

### Границы массивов

- Всегда проверять индексы перед доступом к элементам массива
- Использовать вспомогательные функции для безопасного доступа

```c
// Безопасный доступ к элементу массива
static inline uint8_t array_get_safe(const uint8_t *array, uint8_t index, 
                                   uint8_t array_size, uint8_t default_value) {
    if (index >= array_size) {
        LOGE(__func__, "Index %d out of bounds (size %d)", index, array_size);
        return default_value;
    }
    return array[index];
}
```

### NULL-проверки

- Проверять указатели на NULL перед разыменованием
- Предоставлять осмысленное сообщение об ошибке

---

## 9. Работа с оборудованием

### Уровни абстракции

- Разделять низкоуровневый (аппаратнозависимый) и высокоуровневый код
- Изолировать специфические для аппаратной платформы функции

### Управление питанием

- Явно включать/выключать периферию когда она не используется
- Минимизировать потребление энергии в критических участках

### Тайминги

- Четко указывать и соблюдать временные ограничения
- Учитывать задержки в документации

---

## 10. Примеры правильного кода

### Определение функции с проверкой параметров

```c
/**
 * @brief Выбирает канал АЦП для измерения
 *
 * @param channel Номер канала (0-7)
 * @return ads7138_status_t ADS7138_STATUS_OK при успехе, код ошибки при неудаче
 */
ads7138_status_t ads7138_select_channel(const uint8_t channel) {
    // Проверка параметров
    if (channel > MANUAL_CHID_AIN7) {
        LOGE("ads7138", "Invalid channel number: %d", channel);
        return ADS7138_STATUS_INVALID_PARAMETER;
    }
    
    LOGI(__func__, "Selecting channel %d", channel);
    
    // Сохранить текущий канал
    g_current_channel = channel;
    
    // Команда выбора канала
    if (ds28e18_i2c_write_register(g_dev_addr, REG_CHANNEL_SEL, channel & 0x07) != DS28E18_I2C_STATUS_OK) {
        return ADS7138_STATUS_COMMUNICATION_ERROR;
    }
    return ADS7138_STATUS_OK;
}
```

### Безопасный доступ к массиву

```c
uint16_t ads7138_get_conversion_time_ms(void) {
    uint8_t osr_cfg = 0;
    
    if (ds28e18_i2c_read_register(g_dev_addr, REG_OSR_CFG, &osr_cfg) != DS28E18_I2C_STATUS_OK) {
        LOGE("ads7138", "Failed to read OSR configuration");
        return 136; // Значение по умолчанию в случае ошибки
    }
    
    // Проверка границ
    if (osr_cfg > OSR_128) {
        osr_cfg = OSR_128;
    }
    
    // Безопасный доступ к массиву
    return array_get_safe_u16(osr_conversion_time_ms, osr_cfg, 
                            OSR_CONVERSION_TIME_MS_SIZE, 136, 
                            "osr_conversion_time_ms");
}
```

### Обработка ошибок и логирование

```c
ds28e18_core_status_t ds28e18_run_sequencer(const uint16_t address, const uint16_t length) {
    // Создание параметров команды
    uint8_t parameters[3];
    parameters[0] = address & 0xFF;                           
    parameters[1] = ((length << 1) & 0xFE) | ((address >> 8) & 0x01); 
    parameters[2] = (length >> 7) & 0x03;                    

    // Расчет времени выполнения
    int16_t total_sequencer_time = SPU_DELAY_T_OP_MSEC + (length / 10) + (length / 20) + g_sequencer_delay_time;

    // Выполнение команды
    uint8_t result[3]; 
    if (ds28e18_run_command(DS28E18_CMD_RUN_SEQUENCER, parameters, sizeof(parameters), 
                         total_sequencer_time, result) != DS28E18_CORE_STATUS_OK) {
        LOGE(__func__, "Error executing Run Sequencer");
        return DS28E18_CORE_STATUS_SEQUENCER_ERROR;
    }

    // Проверка результата
    switch (result[0]) {
        case DS28E18_STATUS_SUCCESS:
            LOGI(__func__, "Run Sequencer executed successfully");
            return DS28E18_CORE_STATUS_OK;
            
        case DS28E18_STATUS_POR_OCCURRED:
            LOGE(__func__, "Error in Run Sequencer: POR occurred (0x44)");
            return DS28E18_CORE_STATUS_POR_ERROR;
        
        // ... другие проверки ...
            
        default:
            LOGE(__func__, "Unknown error in Run Sequencer: 0x%02X", result[0]);
            return DS28E18_CORE_STATUS_ERROR;
    }
}
```

---

Это руководство должно служить основой для написания надежного, оптимального и читаемого кода. Соблюдение этих стандартов повысит качество кода, облегчит сопровождение и отладку, а также упростит совместную работу над проектом.